{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-authentication-session This library provides a zend-expressive-authentication adapter that handles form-based username/password authentication credentials where the user details are subsequently stored in a session. Installation Run the following to install this library: $ composer require zendframework/zend-expressive-authentication-session Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Home"},{"location":"#zend-expressive-authentication-session","text":"This library provides a zend-expressive-authentication adapter that handles form-based username/password authentication credentials where the user details are subsequently stored in a session.","title":"zend-expressive-authentication-session"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-authentication-session","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-authentication-session/v1/intro/'; });","title":"_intro"},{"location":"v1/config/","text":"Configuration You will need to provide configuration for the adapter to work correctly: You will need to alias the zend-expressive-authentication AuthenticationInterface to the package's PhpSession implementation. You will need to ensure a zend-expressive-authentication UserRepositoryInterface implementation is available and configured. You will need to provide a factory capable of generating a UserInterface instance, if you do not want to use the default provided by zend-expressive-authentication. You will need to provide a URL or path to which the authentication middleware will redirect if no user is discovered in the session. Example Below is an example demonstrating authentication configuration you might provide when using zend-expressive-authentication-session. In particular: It aliases the PdoDatabase user repository implementation from zend-expressive-authentication as the UserRepositoryInterface service. It aliases the PhpSession adapter from this package to the AuthenticationInterface service. It does not configure a Zend\\Expressive\\Authentication\\UserInterface service, opting to use the default provided by zend-expressive-authentication. It configures the path /login as the URL to which unauthenticated users will be redirected. // in a config/autoload/*.global.php file: declare(strict_types=1); use Zend\\Expressive\\Authentication\\AuthenticationInterface; use Zend\\Expressive\\Authentication\\Session\\PhpSession; use Zend\\Expressive\\Authentication\\UserRepositoryInterface; use Zend\\Expressive\\Authentication\\UserRepository\\PdoDatabase; return [ 'dependencies' => [ 'aliases' => [ AuthenticationInterface::class => PhpSession::class, UserRepositoryInterface::class => PdoDatabase::class, ], ], 'authentication' => [ 'redirect' => '/login', ], ]; Handling the login Once you have configured the adapter, you will also need to write a handler that will handle login attempts .","title":"Configuration"},{"location":"v1/config/#configuration","text":"You will need to provide configuration for the adapter to work correctly: You will need to alias the zend-expressive-authentication AuthenticationInterface to the package's PhpSession implementation. You will need to ensure a zend-expressive-authentication UserRepositoryInterface implementation is available and configured. You will need to provide a factory capable of generating a UserInterface instance, if you do not want to use the default provided by zend-expressive-authentication. You will need to provide a URL or path to which the authentication middleware will redirect if no user is discovered in the session.","title":"Configuration"},{"location":"v1/config/#example","text":"Below is an example demonstrating authentication configuration you might provide when using zend-expressive-authentication-session. In particular: It aliases the PdoDatabase user repository implementation from zend-expressive-authentication as the UserRepositoryInterface service. It aliases the PhpSession adapter from this package to the AuthenticationInterface service. It does not configure a Zend\\Expressive\\Authentication\\UserInterface service, opting to use the default provided by zend-expressive-authentication. It configures the path /login as the URL to which unauthenticated users will be redirected. // in a config/autoload/*.global.php file: declare(strict_types=1); use Zend\\Expressive\\Authentication\\AuthenticationInterface; use Zend\\Expressive\\Authentication\\Session\\PhpSession; use Zend\\Expressive\\Authentication\\UserRepositoryInterface; use Zend\\Expressive\\Authentication\\UserRepository\\PdoDatabase; return [ 'dependencies' => [ 'aliases' => [ AuthenticationInterface::class => PhpSession::class, UserRepositoryInterface::class => PdoDatabase::class, ], ], 'authentication' => [ 'redirect' => '/login', ], ];","title":"Example"},{"location":"v1/config/#handling-the-login","text":"Once you have configured the adapter, you will also need to write a handler that will handle login attempts .","title":"Handling the login"},{"location":"v1/intro/","text":"zend-expressive-authentication-session This library provides a zend-expressive-authentication adapter that handles form-based username/password authentication credentials where the user details are subsequently stored in a session. When a user who has not previously authenticated hits the middleware, it will redirect to a page asking for their credentials, as a username/password combination. When they submit this page with valid credentials, the adapter will store user information (which minimally includes the username, but can also include authorization roles and other information). Subsequent requests hitting the authentication middleware will then pull the user data from the session, marking the user as authenticated.","title":"Introduction"},{"location":"v1/intro/#zend-expressive-authentication-session","text":"This library provides a zend-expressive-authentication adapter that handles form-based username/password authentication credentials where the user details are subsequently stored in a session. When a user who has not previously authenticated hits the middleware, it will redirect to a page asking for their credentials, as a username/password combination. When they submit this page with valid credentials, the adapter will store user information (which minimally includes the username, but can also include authorization roles and other information). Subsequent requests hitting the authentication middleware will then pull the user data from the session, marking the user as authenticated.","title":"zend-expressive-authentication-session"},{"location":"v1/login-handler/","text":"Handling an initial login When you have configured the adapter, you can drop in the zend-expressive-authentication AuthenticationMiddleware anywhere you need to ensure you have an authenticated user. However, how do you handle the initial authentication? In the previous chapter , we indicated that you need to configure a path to which to redirect when the adapter does not detect a user. In this chapter, we'll detail how to create a login handler for processing user credentials. Roughly, what we need to do is: Create a handler that will both display and handle a login form, redirecting to the originally requested location once a successful authentication occurs. Create a template with a form for capturing the username and password. Create a route to the new handler. Create the handler We will use the zend-expressive CLI tooling to generate our handler, as well as the related factory and template: $ ./vendor/bin/expressive handler:create \"App\\Login\\LoginHandler\" By default, if you have a configured template engine, this will do the following: Create the handler for you. Create logic in the handler to render a template and return the contents in a response. Create a factory for the handler. Create a template for you in an appropriate directory. When it does these things, it provides you with the paths to each as well. In our case, we are using the PlatesPHP templating integration , with a flat application structure, and the following files were either created or updated: src/App/Login/LoginHandler.php , which contains the handler class itself. src/App/Login/LoginHandlerFactory.php , which contains the factory for the handler. config/autoload/zend-expressive-tooling-factories.global.php , which maps the handler to its factory for the DI container. templates/app/login.phtml , which contains our template. Now that we have created the handler, we can edit it to do the work we need. Our handler will react to two different HTTP methods. For an initial login request, the GET method will be used, and we will need to display our template. When we do, we will also memoize the originally requested URI (using the Referer request header). When the user submits the form, it will be via the POST method. When this happens, we will need to validate the submitted credentials; we will do this using the PhpSession adapter from this package. If login is successful, we will redirect to the originally requested URI, using the value we previously stored in our session. If login fails, we will display our template, adding an error message indicating the credentials were invalid. The generated handler will already compose the TemplateRendererInterface , and render a template. We will need to add a constructor dependency on the PhpSession adapter, and store that value in a property. Additionally, since we will be performing a redirect for successful POST requests, we will need to add a requirement on Zend\\Diactoros\\Response\\RedirectResponse in addition to the logic changes in the handler. The end result should look like this: namespace App\\Login; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Diactoros\\Response\\RedirectResponse; // add this line use Zend\\Expressive\\Authentication\\Session\\PhpSession; // add this line use Zend\\Expressive\\Session\\SessionInterface; // add this line use Zend\\Expressive\\Authentication\\UserInterface; // add this line use Zend\\Expressive\\Template\\TemplateRendererInterface; class LoginHandler implements RequestHandlerInterface { private const REDIRECT_ATTRIBUTE = 'authentication:redirect'; /** @var PhpSession */ private $adapter; /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer, PhpSession $adapter) { $this->renderer = $renderer; $this->adapter = $adapter; } public function handle(ServerRequestInterface $request) : ResponseInterface { $session = $request->getAttribute('session'); $redirect = $this->getRedirect($request, $session); // Handle submitted credentials if ('POST' === $request->getMethod()) { return $this->handleLoginAttempt($request, $session, $redirect); } // Display initial login form $session->set(self::REDIRECT_ATTRIBUTE, $redirect); return new HtmlResponse($this->renderer->render( 'app::login', [] )); } private function getRedirect( ServerRequestInterface $request, SessionInterface $session ) : string { $redirect = $session->get(self::REDIRECT_ATTRIBUTE); if (! $redirect) { $redirect = $request->getHeaderLine('Referer'); if (in_array($redirect, ['', '/login'], true)) { $redirect = '/'; } } return $redirect; } private function handleLoginAttempt( ServerRequestInterface $request, SessionInterface $session, string $redirect ) : ResponseInterface { // User session takes precedence over user/pass POST in // the auth adapter so we remove the session prior // to auth attempt $session->unset(UserInterface::class); // Login was successful if ($this->adapter->authenticate($request)) { $session->unset(self::REDIRECT_ATTRIBUTE); return new RedirectResponse($redirect); } // Login failed return new HtmlResponse($this->renderer->render( 'app::login', ['error' => 'Invalid credentials; please try again'] )); } } With these changes in place, our handler is now ready. However, we need to update our factory, as we've added a new dependency! To do this, run the following from the command line, in the project root directory: $ rm src/App/Login/LoginHandlerFactory.php $ ./vendor/bin/expressive factory:create \"App\\Login\\LoginHandler\" This will regenerate the factory for you. Edit the template We will now edit the template. The main considerations are: It needs to have a form that submits back to the login page. The form needs both a username and a password field. We need to display an error message if one was provided. Our application is built off the skeleton, and so we are currently using Bootstrap for a UI framework. We are also using PlatesPHP as noted earlier. As such, we will update the template in templates/app/login.phtml to read as follows: <div class=\"container\"> <div class=\"row\"> <div class=\"col-sm\"><form action=\"<?= $this->url('login') ?>\" method=\"post\"> <?php if (isset($error)) : ?> <div class=\"alert alert-danger\" role=\"alert\"> <?= $this->escapeHtml($error) ?> </div> <?php endif ?> <div class=\"form-group\"> <label for=\"username\">Username</label> <input type=\"text\" class=\"form-control\" id=\"username\" name=\"username\" placeholder=\"Enter username\"> </div> <div class=\"form-group\"> <label for=\"password\">Password</label> <input type=\"password\" class=\"form-control\" id=\"password\" name=\"password\" placeholder=\"Password\"> </div> <button type=\"submit\" class=\"btn btn-primary\">Submit</button> </form></div> </div> </div> Template location and structure Keep in mind the following when reading the above sample: If you are using the modular structure, the template may be in a different location. Use the output from the expressive handler:create command to determine the exact location. If you are using a different template engine, the syntax of the template may vary. The HTML may need to vary based on your own site's UI framework and CSS. Create the route Now that we have the handler and template created, we need to create a route for the new handler that handles two HTTP methods: GET for displaying the initial form, and POST for validating submitted credentials. Open up your config/routes.php file, and edit it to add the following within its callback: $app->route( '/login', [ Zend\\Expressive\\Session\\SessionMiddleware::class, App\\Login\\LoginHandler::class, ], ['GET', 'POST'], 'login' ); Understanding the routing You may not be familiar with the route() method, or middleware pipelines. If the above doesn't make sense, keep reading for an explanation. First, we are using the route() method, as we want to create a single route to respond to multiple HTTP methods. This method has a required third argument, which is an array of HTTP methods; we specify GET and POST in this array. Second, we are indicating that we want the route to respond to the exact path /login ; we provide this via the initial method argument. Third, we are providing a name for this route via the optional fourth argument; this is what allows us to call $this->url('login') in our template in order to generate the URL to the login page. Finally, for the middleware argument, we are providing a pipeline , by providing an array of middleware to execute. The first item in the pipeline is the SessionMiddleware from zend-expressive-session; this is required to ensure we have a session container injected into the request. The second item is our login handler itself, which will then do the actual work of creating a response. With this route in place, any routes we write that require authentication will now: Redirect to the /login page, which will require that: A user provides credentials and submits the form back to the /login page, which will: Process the credentials via the PhpSession adapter, which will store identified user details in the session, and: Ultimately give them access (assuming any roles associated with them are authorized), and: Redirect them back to the originally requested page. In the next chapter, we will detail how to require authentication for individual handlers .","title":"Login Handlers"},{"location":"v1/login-handler/#handling-an-initial-login","text":"When you have configured the adapter, you can drop in the zend-expressive-authentication AuthenticationMiddleware anywhere you need to ensure you have an authenticated user. However, how do you handle the initial authentication? In the previous chapter , we indicated that you need to configure a path to which to redirect when the adapter does not detect a user. In this chapter, we'll detail how to create a login handler for processing user credentials. Roughly, what we need to do is: Create a handler that will both display and handle a login form, redirecting to the originally requested location once a successful authentication occurs. Create a template with a form for capturing the username and password. Create a route to the new handler.","title":"Handling an initial login"},{"location":"v1/login-handler/#create-the-handler","text":"We will use the zend-expressive CLI tooling to generate our handler, as well as the related factory and template: $ ./vendor/bin/expressive handler:create \"App\\Login\\LoginHandler\" By default, if you have a configured template engine, this will do the following: Create the handler for you. Create logic in the handler to render a template and return the contents in a response. Create a factory for the handler. Create a template for you in an appropriate directory. When it does these things, it provides you with the paths to each as well. In our case, we are using the PlatesPHP templating integration , with a flat application structure, and the following files were either created or updated: src/App/Login/LoginHandler.php , which contains the handler class itself. src/App/Login/LoginHandlerFactory.php , which contains the factory for the handler. config/autoload/zend-expressive-tooling-factories.global.php , which maps the handler to its factory for the DI container. templates/app/login.phtml , which contains our template. Now that we have created the handler, we can edit it to do the work we need. Our handler will react to two different HTTP methods. For an initial login request, the GET method will be used, and we will need to display our template. When we do, we will also memoize the originally requested URI (using the Referer request header). When the user submits the form, it will be via the POST method. When this happens, we will need to validate the submitted credentials; we will do this using the PhpSession adapter from this package. If login is successful, we will redirect to the originally requested URI, using the value we previously stored in our session. If login fails, we will display our template, adding an error message indicating the credentials were invalid. The generated handler will already compose the TemplateRendererInterface , and render a template. We will need to add a constructor dependency on the PhpSession adapter, and store that value in a property. Additionally, since we will be performing a redirect for successful POST requests, we will need to add a requirement on Zend\\Diactoros\\Response\\RedirectResponse in addition to the logic changes in the handler. The end result should look like this: namespace App\\Login; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Diactoros\\Response\\RedirectResponse; // add this line use Zend\\Expressive\\Authentication\\Session\\PhpSession; // add this line use Zend\\Expressive\\Session\\SessionInterface; // add this line use Zend\\Expressive\\Authentication\\UserInterface; // add this line use Zend\\Expressive\\Template\\TemplateRendererInterface; class LoginHandler implements RequestHandlerInterface { private const REDIRECT_ATTRIBUTE = 'authentication:redirect'; /** @var PhpSession */ private $adapter; /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer, PhpSession $adapter) { $this->renderer = $renderer; $this->adapter = $adapter; } public function handle(ServerRequestInterface $request) : ResponseInterface { $session = $request->getAttribute('session'); $redirect = $this->getRedirect($request, $session); // Handle submitted credentials if ('POST' === $request->getMethod()) { return $this->handleLoginAttempt($request, $session, $redirect); } // Display initial login form $session->set(self::REDIRECT_ATTRIBUTE, $redirect); return new HtmlResponse($this->renderer->render( 'app::login', [] )); } private function getRedirect( ServerRequestInterface $request, SessionInterface $session ) : string { $redirect = $session->get(self::REDIRECT_ATTRIBUTE); if (! $redirect) { $redirect = $request->getHeaderLine('Referer'); if (in_array($redirect, ['', '/login'], true)) { $redirect = '/'; } } return $redirect; } private function handleLoginAttempt( ServerRequestInterface $request, SessionInterface $session, string $redirect ) : ResponseInterface { // User session takes precedence over user/pass POST in // the auth adapter so we remove the session prior // to auth attempt $session->unset(UserInterface::class); // Login was successful if ($this->adapter->authenticate($request)) { $session->unset(self::REDIRECT_ATTRIBUTE); return new RedirectResponse($redirect); } // Login failed return new HtmlResponse($this->renderer->render( 'app::login', ['error' => 'Invalid credentials; please try again'] )); } } With these changes in place, our handler is now ready. However, we need to update our factory, as we've added a new dependency! To do this, run the following from the command line, in the project root directory: $ rm src/App/Login/LoginHandlerFactory.php $ ./vendor/bin/expressive factory:create \"App\\Login\\LoginHandler\" This will regenerate the factory for you.","title":"Create the handler"},{"location":"v1/login-handler/#edit-the-template","text":"We will now edit the template. The main considerations are: It needs to have a form that submits back to the login page. The form needs both a username and a password field. We need to display an error message if one was provided. Our application is built off the skeleton, and so we are currently using Bootstrap for a UI framework. We are also using PlatesPHP as noted earlier. As such, we will update the template in templates/app/login.phtml to read as follows: <div class=\"container\"> <div class=\"row\"> <div class=\"col-sm\"><form action=\"<?= $this->url('login') ?>\" method=\"post\"> <?php if (isset($error)) : ?> <div class=\"alert alert-danger\" role=\"alert\"> <?= $this->escapeHtml($error) ?> </div> <?php endif ?> <div class=\"form-group\"> <label for=\"username\">Username</label> <input type=\"text\" class=\"form-control\" id=\"username\" name=\"username\" placeholder=\"Enter username\"> </div> <div class=\"form-group\"> <label for=\"password\">Password</label> <input type=\"password\" class=\"form-control\" id=\"password\" name=\"password\" placeholder=\"Password\"> </div> <button type=\"submit\" class=\"btn btn-primary\">Submit</button> </form></div> </div> </div>","title":"Edit the template"},{"location":"v1/login-handler/#create-the-route","text":"Now that we have the handler and template created, we need to create a route for the new handler that handles two HTTP methods: GET for displaying the initial form, and POST for validating submitted credentials. Open up your config/routes.php file, and edit it to add the following within its callback: $app->route( '/login', [ Zend\\Expressive\\Session\\SessionMiddleware::class, App\\Login\\LoginHandler::class, ], ['GET', 'POST'], 'login' );","title":"Create the route"},{"location":"v1/requiring-authentication/","text":"Configuring Handlers To Require Authentication In the previous chapter , we detailed writing a handler to display a login form for submitting credentials. That handler then redirects back to the original URL that required authentication. This means that the original handler needs to have the AuthenticationMiddleware as part of its pipeline. Additionally, this package depends on the zend-expressive-session SessionMiddleware being present and in the pipeline before the zend-expressive-authentication AuthenticationMiddleware , as the PhpSession adapter it provides requires access to the session container via the request. There are three ways to accomplish this: Requiring authentication everywhere. Requiring authentication for subpaths of the application. Requiring authentication for individual routes. Requiring authentication everywhere With this approach, every request other than the one to the login form itself will require authentication. To make this possible, you will need to decorate the zend-expressive-authentication AuthenticationMiddleware so that you can exclude that particular path. As an example, you could do the following in the config/pipeline.php file, before the RouteMiddleware somewhere: // Pipe in the session middleware $app->pipe(Zend\\Expressive\\Session\\SessionMiddleware::class); // Pipe a handler that checks to see if authentication is needed: $app->pipe($factory->callable( // $container is present within the callback, and refers to the DI container. function ($request, $handler) use ($container) { if ($request->getUri()->getPath() === '/login') { // Login request; do not require the authentication middleware return $handler->handle($request); } // All other requests require the authentication middleware $authenticationMiddleware = $container->get( Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class ); return $authenticationMiddleware->process($request, $handler); } )); Requiring authentication for subpaths of the application If you know all handlers under a given subpath of the application require authentication, you can use Stratigility's path segregation features to add authentication. For example, consider the following within the config/pipeline.php file, which adds authentication to any path starting with /admin : // Add this within the import section of the file: use function Zend\\Stratigility\\path; // Add this within the callback, before the routing middleware: $app->pipe(path('/admin', $factory->pipeline( Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class ))); Requiring authentication for individual routes The most granular approach involves adding authentication to individual routes. In such cases, you will create a route-specific middleware pipeline . As an example, if we wanted authentication for each of the routes that use the path /admin/users[/\\d+] , we could do the following within our config/routes.php file: $app->get('/admin/users[/\\d+]', [ Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Users\\UsersHandler::class, ], 'users'); $app->post('/admin/users', [ Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Users\\CreateUserHandler::class, ]); $app->post('/admin/users[/\\d+]', [ Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Users\\UpdateUserHandler::class, ]); Note that each pipeline contains both the session and authentication middleware!","title":"Handlers Requiring Authentication"},{"location":"v1/requiring-authentication/#configuring-handlers-to-require-authentication","text":"In the previous chapter , we detailed writing a handler to display a login form for submitting credentials. That handler then redirects back to the original URL that required authentication. This means that the original handler needs to have the AuthenticationMiddleware as part of its pipeline. Additionally, this package depends on the zend-expressive-session SessionMiddleware being present and in the pipeline before the zend-expressive-authentication AuthenticationMiddleware , as the PhpSession adapter it provides requires access to the session container via the request. There are three ways to accomplish this: Requiring authentication everywhere. Requiring authentication for subpaths of the application. Requiring authentication for individual routes.","title":"Configuring Handlers To Require Authentication"},{"location":"v1/requiring-authentication/#requiring-authentication-everywhere","text":"With this approach, every request other than the one to the login form itself will require authentication. To make this possible, you will need to decorate the zend-expressive-authentication AuthenticationMiddleware so that you can exclude that particular path. As an example, you could do the following in the config/pipeline.php file, before the RouteMiddleware somewhere: // Pipe in the session middleware $app->pipe(Zend\\Expressive\\Session\\SessionMiddleware::class); // Pipe a handler that checks to see if authentication is needed: $app->pipe($factory->callable( // $container is present within the callback, and refers to the DI container. function ($request, $handler) use ($container) { if ($request->getUri()->getPath() === '/login') { // Login request; do not require the authentication middleware return $handler->handle($request); } // All other requests require the authentication middleware $authenticationMiddleware = $container->get( Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class ); return $authenticationMiddleware->process($request, $handler); } ));","title":"Requiring authentication everywhere"},{"location":"v1/requiring-authentication/#requiring-authentication-for-subpaths-of-the-application","text":"If you know all handlers under a given subpath of the application require authentication, you can use Stratigility's path segregation features to add authentication. For example, consider the following within the config/pipeline.php file, which adds authentication to any path starting with /admin : // Add this within the import section of the file: use function Zend\\Stratigility\\path; // Add this within the callback, before the routing middleware: $app->pipe(path('/admin', $factory->pipeline( Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class )));","title":"Requiring authentication for subpaths of the application"},{"location":"v1/requiring-authentication/#requiring-authentication-for-individual-routes","text":"The most granular approach involves adding authentication to individual routes. In such cases, you will create a route-specific middleware pipeline . As an example, if we wanted authentication for each of the routes that use the path /admin/users[/\\d+] , we could do the following within our config/routes.php file: $app->get('/admin/users[/\\d+]', [ Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Users\\UsersHandler::class, ], 'users'); $app->post('/admin/users', [ Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Users\\CreateUserHandler::class, ]); $app->post('/admin/users[/\\d+]', [ Zend\\Expressive\\Session\\SessionMiddleware::class, Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, App\\Users\\UpdateUserHandler::class, ]); Note that each pipeline contains both the session and authentication middleware!","title":"Requiring authentication for individual routes"}]}